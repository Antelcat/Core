<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var list = new List<string>()
	{
		"sbyte",
		"byte",
		"bool",
		"int",
		"uint",
		"long",
		"ulong",
		"double",
		"float",
		"DateTime"
	};
	var classes = new Dictionary<string,string>();
#>
using Antelcat.Foundation.Core.Extensions;
using Antelcat.Foundation.Core.Interface.Converting;
using System.ComponentModel;
using System.Globalization;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint").ToString()#>;
<# 
foreach(var type in list) { 
	var name = $"{type[0].ToString().ToUpper()}{type.Substring(1)}";
	var className = $"StringTo{name}Converter";
	classes.Add(type,className);
#>
///<summary>
/// Convert between <see cref="string"/> and <see cref="<#=type#>"/>
///</summary>
public class <#=className#> : TypeConverter, IValueConverter, IValueConverter<string,<#=type#>>
{
	public object To(object? input) => (input as string).To<#=name#>();
    public object? From(object? input) => input?.ToString();
	public <#=type#> To(string? input) => input.To<#=name#>();
    public string From(<#=type#> input) => input.ToString(CultureInfo.InvariantCulture);
	public override object ConvertTo(
		ITypeDescriptorContext? _, 
		CultureInfo? __, 
		object? value, 
		Type ___) => To(value);

   	public override object? ConvertFrom(
		ITypeDescriptorContext? _, 
		CultureInfo? __, 
		object value) => From(value);

   	public override bool CanConvertTo(
		ITypeDescriptorContext? _, 
		Type? destinationType) => destinationType == typeof(<#=type#>);

   	public override bool CanConvertFrom(
		ITypeDescriptorContext? _, 
		Type sourceType) => sourceType == typeof(<#=type#>);
}

<# 
}
#>

public static class StringValueConverters
{
	private static readonly Dictionary<Type,IValueConverter> Instances = new ()
	{
<#foreach(var pair in classes) {#>
		{ typeof(<#=pair.Key#>) , new <#=pair.Value#>() },
<#}#>
	};

	public static IValueConverter FindByType(Type type) => Instances.TryGetValue(type,out var ret) 
	? ret 
	: throw new NotSupportedException($"Specified type {type} not supported");
}